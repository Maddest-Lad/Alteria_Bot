import os
import requests
import pathlib
import re
import subprocess
import urllib3
import uuid
import wget

urllib3.disable_warnings()

headers = {
    'Host': 'ifunny.co',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'en-US,en;q=0.9',
    'Connection': 'close',
}

params = {
    's': 'cl',
}

def sanitize_filename(filename):
    """
    Remove or replace characters that aren't allowed in filenames.
    """
    # Remove invalid characters
    filename = re.sub(r'[\\/*?:"<>|]', "", filename)
    
    # Remove leading/trailing dots and spaces, replace periods with underscores
    filename = filename.strip('. ').replace('.', '_')

    return filename

class downloader():

    def download_if(self, url: str):
        response = requests.get(url, params=params, headers=headers, verify=False).text

        # Search for the video tags
        result = re.search('{start}(.*){end}'.format(start='<video', end='</video>'), response).group(1)

        # Now filter down to the data-src link
        video_url = result[result.index("data-src=\"") + 10:result.index(".mp4\"") + 4]

        # Download the video    
        return pathlib.Path(wget.download(video_url, out="Media/Videos"))
    
    def download_image(self, url: str):
        try:
            match = re.search(r"\.(png|jpg|jpeg)(?:\?|$)", url)
            
            if match is None:
                raise ValueError("Invalid URL or unsupported file type")
            
            # Group 1 contains the matched file extension
            filetype = match.group(1)
            
            outpath = f"Media/Images/{str(uuid.uuid4())}.{filetype}" # Unique* Filename
            
            subprocess.run(['wget', '-O', outpath, url])

            return pathlib.Path(outpath)        
                        
        except Exception as e:
            return f"Image Download Error : {e}"

    async def download_yt(self, url: str):
        from pytubefix import YouTube 

        import subprocess
        import shlex

        yt = YouTube(url)

        # Confirm Valid Video
        try:
            yt.check_availability()
        except Exception as ex:
            return(str(ex))

        # Filename & Metadata Info
        BASE_PATH = pathlib.Path("/mnt/md0/Plex/Youtube")
        author = sanitize_filename(yt.author)
        title = sanitize_filename(yt.title)
        print(f"Sanitized title: {title}")

        author = sanitize_filename(yt.author)
        title = sanitize_filename(yt.title)
        print(f"Sanitized title: {title}")

        output_path = BASE_PATH / author

        # Download The Best Quality Video and Audio Tracks, Because Youtube Adaptive/Progressive Streaming Is Funky
        yt.streams.filter(only_video=True).order_by('resolution').last().download(filename="video", output_path=output_path)
        yt.streams.filter(only_audio=True).order_by('abr').last().download(filename="audio", output_path=output_path)

        #print(f"{output_path}/{title}")

        # Build the Merge Command
        command = f"ffmpeg -i \"{output_path}/video\" -i \"{output_path}/audio\" -c:v copy -c:a copy \"{output_path}/{title}.mkv\""
        args = shlex.split(command) # Use shlex.split to properly split the command string
        subprocess.call(args, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)

        # Delete The Temporary Files
        os.remove(f"{output_path}/video")
        os.remove(f"{output_path}/audio")

        # Look For Captions
        if yt.captions:
            if 'en' in yt.captions:
                yt.captions['en'].download(title=title, output_path=output_path)
            elif 'en-us' in yt.captions:
                yt.captions['en-us'].download(title=title, output_path=output_path)
            # Autogenerated Captions/Transcription (Worst Quality)
            elif 'a.en' in yt.captions:
                yt.captions['a.en'].download(title=title, output_path=output_path)

        return "Video Successfully Downloaded"

if __name__ == "__main__": 
    dl = downloader()
    dl.download_yt("https://www.youtube.com/watch?v=5ai5umy9yH0")
        
